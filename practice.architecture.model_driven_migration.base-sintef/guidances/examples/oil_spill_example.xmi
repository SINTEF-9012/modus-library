<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:GuidanceDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-hYxhZUtztuE40wD3vQwOMg" name="oil_spill_example,_6rkKIJsnEeCui_A0lCfdaQ" guid="-hYxhZUtztuE40wD3vQwOMg" changeDate="2011-06-27T13:06:22.490+0200">
  <mainDescription>&lt;h3>&#xD;
    Oil spill example&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    We use a case study from an existing oil spill analysis application to show the feasibility of the approach.&#xD;
&lt;/p>&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot;>&#xD;
    &lt;span lang=&quot;en-GB&quot;>SINTEF Materials and Chemistry&lt;/span>&lt;span lang=&quot;en-GB&quot;>have a commercial legacy product for&#xD;
    simulating oil drift, which can help predicting the spreading of oil in case of an accidental spill. The system is&#xD;
    implemented by a Fortran simulation back-end and a C++ front-end. Now, they want a transition to a service-oriented&#xD;
    paradigm to more easily adapt to new customer needs and more flexible business models (Oldevik, et al., 2011).&lt;/span>&#xD;
&lt;/p>&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot; dir=&quot;ltr&quot;>&#xD;
    Figure 1 &lt;span lang=&quot;en-GB&quot;>illustrates the existing application. The Fortran simulation core is responsible for&#xD;
    simulating oil drift based on numerical models. It is invoked from a presentation layer written in C++. All input is&#xD;
    file based, and simulation runs in batch mode from some minutes to several days. This approach has worked fine for many&#xD;
    years, but there are some apparent challenges with respect to interoperability, integration, and scalability. The goal&#xD;
    is to migrate the application to meet new market needs while coping with these challenges.&lt;/span>&#xD;
&lt;/p>&#xD;
&lt;blockquote style=&quot;MARGIN-RIGHT: 0px&quot; dir=&quot;ltr&quot;>&#xD;
    &lt;blockquote style=&quot;MARGIN-RIGHT: 0px&quot; dir=&quot;ltr&quot;>&#xD;
        &lt;blockquote style=&quot;MARGIN-RIGHT: 0px&quot; dir=&quot;ltr&quot;>&#xD;
            &lt;blockquote style=&quot;MARGIN-RIGHT: 0px&quot; dir=&quot;ltr&quot;>&#xD;
                &lt;blockquote style=&quot;MARGIN-RIGHT: 0px&quot; dir=&quot;ltr&quot;>&#xD;
                    &lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot; lang=&quot;en-GB&quot;>&#xD;
                        &lt;img style=&quot;WIDTH: 536px; HEIGHT: 438px&quot; alt=&quot;&quot; src=&quot;resources/oil spill.png&quot; width=&quot;600&quot;&#xD;
                        height=&quot;521&quot; />&lt;br />&#xD;
                    &lt;/p>&#xD;
                &lt;/blockquote>&#xD;
            &lt;/blockquote>&#xD;
        &lt;/blockquote>&#xD;
    &lt;/blockquote>&#xD;
&lt;/blockquote>&#xD;
&lt;br style=&quot;PAGE-BREAK-AFTER: avoid; MARGIN-BOTTOM: 0cm&quot; lang=&quot;en-GB&quot; align=&quot;center&quot; />&#xD;
&lt;br />&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot; align=&quot;center&quot;>&#xD;
    &lt;a id=&quot;_Ref287524745&quot; name=&quot;_Ref287524745&quot;>&lt;/a>&lt;font size=&quot;2&quot;>&lt;b>&lt;span lang=&quot;en-GB&quot;>Figure 1: Oil drift prediction&#xD;
    legacy application&lt;/span>&lt;/b>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot; lang=&quot;en-GB&quot;>&#xD;
    &lt;span lang=&quot;en-GB&quot;>We use model-driven engineering techniques to develop&lt;/span>&lt;span lang=&quot;en-GB&quot;>the oil drift&#xD;
    prediction as a service that wraps&lt;/span> &lt;span lang=&quot;en-GB&quot;>the existing simulation engine. UML models are used to&#xD;
    specify service interfaces and the details of the wrapper architecture. From these models, we generate XML schemas for&#xD;
    the web service, Java interface and class implementations of the web service, the architecture of the wrapper, and its&#xD;
    behavioural implementation. Wrapping of the C++ front-end is out of our scope, since this will be re-designed to fit a&#xD;
    web-based interaction paradigm.&lt;/span>&#xD;
&lt;/p>&#xD;
&lt;h4 style=&quot;MARGIN-BOTTOM: 0cm&quot; lang=&quot;en-GB&quot;>&#xD;
    &lt;span lang=&quot;en-GB&quot;>S&lt;/span>&lt;span lang=&quot;en-GB&quot;>ervice Structure and Interface&lt;/span>&#xD;
&lt;/h4>&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot;>&#xD;
    &lt;span lang=&quot;en-GB&quot;>The service itself&lt;/span>&lt;span lang=&quot;en-GB&quot;>is defined by a SoaML «serviceInterface» class, which&#xD;
    implements the service interface with a set of exposed operations (see Figure 2). The most interesting of these is the&#xD;
    «asynch» operation&lt;/span> &lt;span lang=&quot;en-GB&quot;>predictOilDriftAsynch&lt;/span>&lt;span lang=&quot;en-GB&quot;>, which provides the main&#xD;
    service in the oil drift prediction case. Since the execution of a simulation may run for hours, or even days, the&#xD;
    operation is declared as asynchronous.&lt;/span>&#xD;
&lt;/p>&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot;>&#xD;
    &lt;span lang=&quot;en-GB&quot;>The operation will return immediately with only a session id to identify the session. Two additional&#xD;
    helper operations are provided for checking execution status (&lt;/span>&lt;span lang=&quot;en-GB&quot;>getStatus&lt;/span>&lt;span&#xD;
    lang=&quot;en-GB&quot;>) and to retrieve the result upon termination (&lt;/span>&lt;span&#xD;
    lang=&quot;en-GB&quot;>getPredictOilDriftResult&lt;/span>&lt;span lang=&quot;en-GB&quot;>).&lt;/span>&#xD;
&lt;/p>&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot; lang=&quot;en-GB&quot;>&#xD;
    &lt;span lang=&quot;en-GB&quot;>The&lt;/span> &lt;span lang=&quot;en-GB&quot;>PredictOilDriftService&lt;/span>&lt;span lang=&quot;en-GB&quot;>is a structured class&#xD;
    that contains a set of parts:&lt;/span>&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot; lang=&quot;en-GB&quot;>&#xD;
            &lt;span lang=&quot;en-GB&quot;>The&lt;/span> &lt;span lang=&quot;en-GB&quot;>PredictOilDriftServiceController&lt;/span>&lt;span lang=&quot;en-GB&quot;>is&#xD;
            the internal orchestration component for the service. All incoming calls are delegated to the controller, which&#xD;
            implements the operations of the service.&lt;/span>&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot;>&#xD;
            &lt;span lang=&quot;en-GB&quot;>The&lt;/span> &lt;span lang=&quot;en-GB&quot;>DataTransformer&lt;/span>&lt;span lang=&quot;en-GB&quot;>provides operations&#xD;
            for transforming input required by the Fortran simulation engine, and transforming result data after&#xD;
            simulation.&lt;/span>&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot;>&#xD;
            &lt;span lang=&quot;en-GB&quot;>The&lt;/span>&lt;span lang=&quot;en-GB&quot;>FatesWrapper&lt;/span>&lt;span lang=&quot;en-GB&quot;>is an «exe» component,&#xD;
            which wraps the execution of the Fortran simulation program.&lt;/span>&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot;>&#xD;
            &lt;span lang=&quot;en-GB&quot;>The&lt;/span>&lt;span lang=&quot;en-GB&quot;>WeatherServiceIntegrator&lt;/span>&lt;span lang=&quot;en-GB&quot;>provides&#xD;
            operations for integrating with an external weather data provider. It is further de-composed by two parts: a&#xD;
            «restfulWebService» called&lt;/span> &lt;span lang=&quot;en-GB&quot;>WeatherService&lt;/span>&lt;span lang=&quot;en-GB&quot;>and a&#xD;
            «JNI»-component called&lt;/span> &lt;span lang=&quot;en-GB&quot;>GribDataTransformer&lt;/span>&lt;span lang=&quot;en-GB&quot;>.&lt;/span>&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot;>&#xD;
            &lt;span lang=&quot;en-GB&quot;>The&lt;/span> &lt;span lang=&quot;en-GB&quot;>getWeatherInfo&lt;/span>&lt;span lang=&quot;en-GB&quot;>operation gets weather&#xD;
            data from a restful web service that provides binary data in the GRIB format (WMO, 2007). To transform the&#xD;
            GRIB-data to the input format used by the simulation engine, an external native library (in this case DLL) is&#xD;
            integrated by the&lt;/span> &lt;span lang=&quot;en-GB&quot;>GribDataTransformer&lt;/span>&lt;span lang=&quot;en-GB&quot;>.&lt;/span>&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot;>&#xD;
            &lt;span lang=&quot;en-GB&quot;>The&lt;/span>&lt;span lang=&quot;en-GB&quot;>OilDatabase&lt;/span>&lt;span lang=&quot;en-GB&quot;>is a «db jdbc»-component,&#xD;
            which provides oil type information from an SQL database.&lt;/span>&#xD;
        &lt;/p>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot; lang=&quot;en-GB&quot;>&#xD;
    &lt;span lang=&quot;en-GB&quot;>The data types passed in the service interface are&lt;/span>&lt;span lang=&quot;en-GB&quot;>modelled as classes&#xD;
    stereotyped using the SoaML stereotype «MessageType». Apart from the stereotype, the data types are specified with&#xD;
    standard UML classes with attributes and associations.&lt;/span>&#xD;
&lt;/p>&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot; lang=&quot;en-GB&quot;>&#xD;
    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#xD;
    &lt;img alt=&quot;&quot; src=&quot;resources/oil spill uml.png&quot; width=&quot;600&quot; height=&quot;600&quot; />&lt;br />&#xD;
&lt;/p>&#xD;
&lt;br style=&quot;PAGE-BREAK-AFTER: avoid; MARGIN-BOTTOM: 0cm&quot; lang=&quot;en-GB&quot; align=&quot;center&quot; />&#xD;
&lt;br />&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot; align=&quot;center&quot;>&#xD;
    &lt;a id=&quot;_Ref287965331&quot; name=&quot;_Ref287965331&quot;>&lt;/a>&lt;font size=&quot;2&quot;>&lt;b>&lt;span lang=&quot;en-GB&quot;>Figure 2: Oil drift prediction&#xD;
    service – service and wrapper components (structural model excerpt)&lt;/span>&lt;/b>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;h4 style=&quot;MARGIN-BOTTOM: 0cm&quot; lang=&quot;en-GB&quot;>&#xD;
    Behaviour&#xD;
&lt;/h4>&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot;>&#xD;
    &lt;span lang=&quot;en-GB&quot;>Component behaviour is specified for different operations in the migration model. Behaviour is&#xD;
    defined by Activity diagrams that are associated with the operations they implement. Figure&amp;nbsp;3&lt;/span>&lt;span&#xD;
    lang=&quot;en-GB&quot;>shows the behaviour of the&lt;/span> &lt;span lang=&quot;en-GB&quot;>predictOilDriftAsynch&lt;/span>&lt;span&#xD;
    lang=&quot;en-GB&quot;>operation, which is contained in the&lt;/span> &lt;span&#xD;
    lang=&quot;en-GB&quot;>PredictOilDriftServiceController&lt;/span>&lt;span lang=&quot;en-GB&quot;>. All invocations to the service&lt;/span> &lt;span&#xD;
    lang=&quot;en-GB&quot;>PredictOilDriftService&lt;/span>&lt;span lang=&quot;en-GB&quot;>is by convention delegated to its controller part. The&#xD;
    activity diagram specifies the initial behaviour of the operation, up until the call to the executable&#xD;
    component.&lt;/span>&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;span lang=&quot;en-GB&quot;>Our approach for behavioural modelling is tied to the target language, in this case Java, since we&#xD;
    in some cases embed small portions of code inside actions. We could get around this by incorporating a richer set of&#xD;
    UML actions that can cope with variable declarations, property references, and object creation. This extension will be&#xD;
    investigated as part of future work.&lt;/span>&#xD;
&lt;/p>&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot;>&#xD;
    &lt;font style=&quot;FONT-SIZE: 11pt&quot; size=&quot;2&quot;>&lt;span&#xD;
    lang=&quot;en-GB&quot;>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#xD;
    &lt;img alt=&quot;&quot; src=&quot;resources/oil spill uml2.png&quot; width=&quot;600&quot; height=&quot;600&quot; />&lt;/span>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot; align=&quot;center&quot;>&#xD;
    &lt;a id=&quot;_Ref287966729&quot; name=&quot;_Ref287966729&quot;>&lt;/a>&lt;font size=&quot;2&quot;>&lt;b>&lt;span lang=&quot;en-GB&quot;>Figure 3: Oil drift prediction&#xD;
    service – behavioural model (excerpt)&lt;/span>&lt;/b>&lt;/font>&#xD;
&lt;/p>&#xD;
&lt;p style=&quot;MARGIN-BOTTOM: 0cm&quot; lang=&quot;en-GB&quot;>&#xD;
    &lt;span lang=&quot;en-GB&quot;>The purpose of the migration models is to automate as much as possible the legacy system migration&#xD;
    process. We have developed a set of transformations, or code generators, to support the transition from models to&#xD;
    deployable services. They were implemented with the model to text transformation tool MOFScript&lt;/span>&lt;span&#xD;
    lang=&quot;en-GB&quot;>(Eclipse Foundation, 2011c).&lt;/span>&#xD;
&lt;/p></mainDescription>
  <attachments>resources/oil spill.png|resources/oil spill uml.png|resources/oil spill uml2.png</attachments>
</org.eclipse.epf.uma:GuidanceDescription>
