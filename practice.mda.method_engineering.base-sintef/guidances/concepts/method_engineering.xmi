<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-1Yth4QidlEV-XjBcfvgC8Q" name="new_supporting_material,_h08DgFY2EeCmC7fuNTHhhQ" guid="-1Yth4QidlEV-XjBcfvgC8Q" changeDate="2011-06-10T09:28:00.442+0200">
  <mainDescription>&lt;h3>&#xD;
    Methods and practices&#xD;
&lt;/h3>&#xD;
&lt;h4>&#xD;
    Definition of method and practice&#xD;
&lt;/h4>&#xD;
&lt;p class=&quot;section&quot;>&#xD;
    A &lt;em>&lt;strong>method&lt;/strong>&lt;/em> (or methodology) is a systematic way of doing things in a particular discipline. For&#xD;
    the purpose of of the MODUS Methodology Framework, the relevant discipline is model-driven software engineering, where&#xD;
    the aim is the creation or modification of a satisfactory software system or service. In a model-driven software&#xD;
    engineering approach there is an emphasis on the creation and use of models in the development of the software system&#xD;
    or service.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;section&quot;>&#xD;
    A &lt;strong>&lt;em>practice&lt;/em>&lt;/strong> is a general, repeatable approach to doing something with a specific purpose in&#xD;
    mind, providing a systematic and verifiable way of addressing a particular aspect of the work at hand. It should have a&#xD;
    clear goal expressed in terms of the results its use will achieve and provide guidance on what is to be done to achieve&#xD;
    the goal and to verify that it has been achieved. Such practices may include specific approaches for software design,&#xD;
    coding, testing at various levels, integration, organizing and managing the development team, etc. Examples of&#xD;
    practices are Iterative Development, Use Case Driven Development and Test Driven Development. A definition of a&#xD;
    practice&amp;nbsp;includes&amp;nbsp;includes method content (e.g. tasks, roles, work products, guidance, etc.) and process&#xD;
    content (e.g. capability patterns) prescribing how to adopt and use the practice.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Composition of practices into methods&#xD;
&lt;/h4>&#xD;
&lt;p class=&quot;section&quot;>&#xD;
    Methods may be considered as composed from well-defined practices to that are selected to cover all or a&#xD;
    partial&amp;nbsp;set of software&amp;nbsp;development phases. The method guides the usage of these practices. A practice&#xD;
    typically builds upon underlying concepts or paradigms (e.g. a particular modelling language or architectural style).&#xD;
    Examples of such paradigms are: Object-oriented software development, component-based software development and&#xD;
    service-oriented software development.&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;section&quot;>&#xD;
    While each practice must be individually definable, a practice will of necessity have expectations on work done outside&#xD;
    its scope that must be met by other practices within a complete method. For example, a testing practice will place&#xD;
    certain expectations on the concept of a unit that is central to a coding practice and the concept of a testable&#xD;
    requirement generated by an analysis practice. A good method framework must provide effective, easy-to-use means for&#xD;
    resolving the expectations across a consistent set of practices and weaving them together into a complete, enactable&#xD;
    method.&#xD;
&lt;/p>&#xD;
&lt;h4 class=&quot;section&quot;>&#xD;
    Enactment of methods&#xD;
&lt;/h4>&#xD;
&lt;p class=&quot;section&quot;>&#xD;
    A method must be enactable. The enactment of a method can be defined as the carrying out of that method in the context&#xD;
    of a specific project effort. Within this context, the practices within the method may be considered use cases for the&#xD;
    work the must be carried out to achieve the project objectives, with each practice providing a specific aspect of the&#xD;
    overall method.&lt;br />&#xD;
    Enacting a method includes using the method to create elements such as tasks and work products during the software&#xD;
    endeavor, focusing on what to produce and how to produce it. Since software development is a collaborative team-based&#xD;
    effort that involves knowledge workers, enactment of methods should support monitoring and progressing the software&#xD;
    endeavor through human agents foremost and automation secondly.&lt;br />&#xD;
    Enactment is always done by practitioners and involves that members of a team collaborates on decision-making, planning&#xD;
    and execution. Enactment may be partially supported by method repositories and process engines that are linked to tools&#xD;
    such as project management and issue tracking systems.&#xD;
&lt;/p>&#xD;
&lt;a id=&quot;N10023&quot; name=&quot;N10023&quot;>&lt;/a>&lt;a id=&quot;Principles+for+modern+software+development&quot;&#xD;
name=&quot;Principles+for+modern+software+development&quot;>&lt;/a> &#xD;
&lt;h3 class=&quot;underlined_5&quot;>&#xD;
    Principles for modern software development&#xD;
&lt;/h3>&#xD;
&lt;p class=&quot;section&quot;>&#xD;
    Software development methodologies has evolved gradually over the past years. A modern software development methodology&#xD;
    typically follows a set of these principles:&#xD;
&lt;/p>&#xD;
&lt;div class=&quot;section&quot;>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Architecture-centric, e.g. service-oriented architecture&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Iterative and incremental process&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Service- and component-orientation&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Manage a highly dynamic environment. &#xD;
            &lt;ul>&#xD;
                &lt;li>&#xD;
                    Processes to support iterative and incremental development.&#xD;
                &lt;/li>&#xD;
                &lt;li>&#xD;
                    Software system mush be designed to be easy to change.&#xD;
                &lt;/li>&#xD;
            &lt;/ul>&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Model-based&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            “Round-trip” engineering&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Divide and conquer&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Quality check&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Configurable process&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
&lt;/div>&#xD;
&lt;a id=&quot;N10041&quot; name=&quot;N10041&quot;>&lt;/a>&lt;a id=&quot;Process&quot; name=&quot;Process&quot;>&lt;/a> &#xD;
&lt;h3 class=&quot;underlined_5&quot;>&#xD;
    Delivery process&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    The delivery process depends on the type of system. It is very rare that a brand new system is being developed. Most of&#xD;
    the cases developers are involved in re-engineering or modification. Re-engineering is a radical process of&#xD;
    re-designing an old system while modification is a process of fixing a major problem or changing a feature. Another&#xD;
    typical process scenario is to add new functionality to an existing system, by developing and integrating a new module&#xD;
    (e.g. component or service).&#xD;
&lt;/p>&#xD;
&lt;a id=&quot;N10047&quot; name=&quot;N10047&quot;>&lt;/a>&lt;a id=&quot;Existing+methodologies&quot; name=&quot;Existing+methodologies&quot;>&lt;/a> &#xD;
&lt;h2 class=&quot;underlined_10&quot;>&#xD;
    Existing methodologies&#xD;
&lt;/h2>&#xD;
&lt;div class=&quot;section&quot;>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            The Rational Unified Proces(RUP) is an iterative software development process created by the Rational Software&#xD;
            Corporation. It is an adaptable process framework that describes how to develop software effectively using&#xD;
            proven techniques.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            KobrA methodology for modeling architectures is a systematic approach to using UML that is refreshingly simple&#xD;
            and straightforward. One of the problems on components is that the term &quot;component&quot; is so heavily overloaded .&#xD;
            To overcome this, KobrA has introduced a new term &quot;Komponent&quot;. Komponents are the &quot;logical&quot; components that&#xD;
            represent the logical building blocks of a software system.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Catalysis is another UML based method for object and component based development.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Select Perspective is a methodology in agile modelling that uses multiple, best-of-breed modelling techniques,&#xD;
            both text and diagram-based.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            The Object Oriented Role Analysise Method (OOram) is a method, based on the concept of role, for performing&#xD;
            object-oriented modeling. OOram is a precursor for the Unified Modeling Language (UML). ( Developed by profesor&#xD;
            Trygve Reenskaug ).&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Some other lightweight methodologies are eXtreme programing (XP), Adaptive Software Development (ASD), SCRUM –&#xD;
            an agile method for project management, and Crystal Clear – an agile developing method.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
&lt;/div>&#xD;
&lt;a id=&quot;N10058&quot; name=&quot;N10058&quot;>&lt;/a>&lt;a id=&quot;Method+engineering&quot; name=&quot;Method+engineering&quot;>&lt;/a> &#xD;
&lt;h2 class=&quot;underlined_10&quot;>&#xD;
    Method engineering&#xD;
&lt;/h2>&#xD;
&lt;div class=&quot;section&quot;>&#xD;
    &lt;p>&#xD;
        &lt;img alt=&quot;&quot; src=&quot;http://www.modelbased.net/mdi/method/guidelines_files/method_method.gif&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        From the engineering perspective, a method is made up of&amp;nbsp;a set of product models and a set of corresponding&#xD;
        process models. A product model represents the concepts that are used in the method, relationships between these&#xD;
        concepts as well as constraints that they have to satisfy. A process model represents the way to accomplish the&#xD;
        development of the corresponding product.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10062&quot; name=&quot;N10062&quot;>&lt;/a>&lt;a id=&quot;Method+engineering+process&quot; name=&quot;Method+engineering+process&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Method engineering process&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        In a method engineering process there are two foci:&#xD;
    &lt;/p>&#xD;
    &lt;ol>&#xD;
        &lt;li>&#xD;
            Re-enginering of existing methodolologies into smaller methods or method chunks and describe the methodology as&#xD;
            a set of configured modules. These method chunks will be stored in a method chunks repository.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Assembly of situation-specific methods based on existing method chunks.&#xD;
        &lt;/li>&#xD;
    &lt;/ol>&#xD;
    &lt;a id=&quot;N10071&quot; name=&quot;N10071&quot;>&lt;/a>&lt;a id=&quot;Method+chunk&quot; name=&quot;Method+chunk&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Method chunk&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        A method chunk is an autonomous and coherent part of a method supporting the realisation of some specific system&#xD;
        development or management activity. Such a modular view of methods favours their adaptation, configuration and&#xD;
        extension. Moreover, this view permits to reuse chunks of a given method in the construction of new ones.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10077&quot; name=&quot;N10077&quot;>&lt;/a>&lt;a id=&quot;Problems+and+opportunities&quot; name=&quot;Problems+and+opportunities&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Problems and opportunities&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        There exist no authoritative compilations of method chunks that can be assembled to fit particular project&#xD;
        contexts, and such that deliverables of applying one method chunk, can be mapped to inputs of another method chunk.&#xD;
        Method chunks are rarely presented as elements that are separated from the problems solved with them, or from the&#xD;
        cases used to illustrate their application. There is no agreed taxonomy of method chunks. Methods are in the heads&#xD;
        of people, and not yet in the services of systems. There are no services to assess which methods to use in a given&#xD;
        situation, given the bounded rationality of the engineer, often, sub-optimal methods are selected, making projects&#xD;
        expensive and crippling system development.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        However, there exists a near-consensus in the Method Engineering community, on the requirements for a method-chunk&#xD;
        repository. There exists a wealth of architectural styles (service oriented, agents,...) that can assist the&#xD;
        development of an MCR. Platforms such as ATHENA’s MPCE are offering infrastructural services, needs-awareness and&#xD;
        proto-communities that are conducive for the MCR development and test.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        To support method engineering we need a modelling and execution platform. This platform must provide use case&#xD;
        users, developers, method chunk managers and method chunk developers appropriate workplaces with services. We also&#xD;
        see the need for both a use case repository and a method chunk repository.&#xD;
    &lt;/p>&#xD;
&lt;/div>&#xD;
&lt;a id=&quot;N10081&quot; name=&quot;N10081&quot;>&lt;/a>&lt;a id=&quot;Software+architecture&quot; name=&quot;Software+architecture&quot;>&lt;/a> &#xD;
&lt;h2 class=&quot;underlined_10&quot;>&#xD;
    Software architecture&#xD;
&lt;/h2>&#xD;
&lt;div class=&quot;section&quot;>&#xD;
    &lt;p>&#xD;
        Even if it is used by many, the term “architecture” has no well established definition. Nevertheless, in the field&#xD;
        of software engineering there is no shortage of more or less overlapping definitions (see for instance&#xD;
        www.sei.cmu.edu/architecture/definitions.html). Here we present one consistent set of definitions targeting&#xD;
        architectural descriptions for software-intensive systems, namely the IEEE Std 1471-2000, IEEE Recommended Practice&#xD;
        for Architectural Description of Software-Intensive Systems. This recommended practice seeks to become a common&#xD;
        frame of reference within which to codify common elements between different architectural description initiatives,&#xD;
        and has become influential and used as a baseline for architectural description frameworks, for instance within&#xD;
        OMG. It reflects generally accepted trends in practices for architectural description and provides a frame of&#xD;
        reference within which future developments in software architectural technology can be deployed.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        According to the recommended practice, software-intensive systems are those complex systems “where software&#xD;
        contributes essential influences to the design, construction, deployment and evolution of the system as a whole”.&#xD;
        The purpose of IEEE Std 1471-2000 is to facilitate the expression and communication of architectures and thereby&#xD;
        lay a foundation for quality and cost gains through standardisation of elements and practices for architectural&#xD;
        description of software-intensive systems. This is in contrast to past attempts at architecture description where&#xD;
        only hardware-related architectural aspects were addressed. With increasingly complex software, architectural&#xD;
        integrity of the software should also be addressed and the recommended practice facilitates this.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        The figure shows the conceptual model of architectural description as defined in IEEE Std 1471-2000.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        &lt;img alt=&quot;&quot; src=&quot;http://www.modelbased.net/mdi/method/guidelines_files/method_ieee_1471.gif&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Starting with system, it is defined to be “a collection of components organized to accomplish a specific function&#xD;
        or set of functions.” For the purposes of the recommended practice, “the&lt;br />&#xD;
        term system encompasses individual applications, systems in the traditional sense, subsystems, systems of systems,&#xD;
        product lines, whole enterprises, and other aggregations of interest.” From this it follows that anything can be a&#xD;
        system as long as it fulfils some purpose (i.e., accomplishes function(s)) and one chooses to view it as a whole.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        A system inhabits an environment, while the environment of a system can influence that system. The environment,&#xD;
        sometimes referred to as the context, “determines the settings and circumstances of developmental, operational,&#xD;
        political, and other influences upon that system. The environment can include other systems that interact with the&#xD;
        system of interest, either directly via interfaces or indirectly in other ways. The environment determines the&#xD;
        boundaries that define the scope of the system of interest relative to other systems”. Essentially, one draws a&#xD;
        line between the system of interest and anything outside that system that influences it in some way. This line is&#xD;
        the interface between the system and its environment.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        A system has one or more stakeholders. A stakeholder has one or more concerns relative to the system. Concerns are&#xD;
        “those interests which pertains to the system’s development, its operation or any other aspects that are critical&#xD;
        or otherwise important to one or more stakeholders.” Typical concerns a stakeholder can have relative to a system&#xD;
        are functionality, performance, security, reliability, safety, etc.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        A system exists to fulfil one or more missions in its environment. The existence of a system has a purpose; it&#xD;
        should meet one or more objectives of one or more stakeholders. Often some of these objectives coincide with&#xD;
        enterprise objectives so that using the system is an efficient use of resources in the enterprise. So far, the&#xD;
        terminology presented has only been related to systems and their environments. However, most of IEEE Std 1471-2000&#xD;
        is concerned with architectural descriptions, and in the following terminology related to this are presented.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        A system has an architecture and this can be described in an architectural description. Note the distinction&#xD;
        between the architecture of a system, which is conceptual, from the description of this architecture, which is&#xD;
        concrete. Architectural description is defined as “a collection of products to document an architecture”. The&#xD;
        architectural description can be divided into one or several views. Each view covers one or more stakeholder&#xD;
        concerns. View is defined as “a representation of a whole system from the perspective of a related set of&#xD;
        concerns”. A view is created according to rules and conventions defined in a viewpoint. Viewpoint is defined as “a&#xD;
        specification of the conventions for constructing and using a view. A pattern or template from which to develop&#xD;
        individual views by establishing the purposes and audience for a view and the techniques for its creation and&#xD;
        analysis”. The distinction between view and viewpoint is analogous to that between a searchlight and what one sees&#xD;
        using the searchlight as shown in the figure below.&#xD;
    &lt;/p>&#xD;
&lt;/div></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
