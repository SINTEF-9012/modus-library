<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-lx14-kyzIGNMXQmAOl6Xcw" name="service_contract,_N-Gp8Df3Ed-Uc_4T-VlC6Q" guid="-lx14-kyzIGNMXQmAOl6Xcw" changeDate="2011-08-04T10:12:13.540+0200">
  <mainDescription>&lt;p>&#xD;
    A service contract based approach defines service specifications that define the roles each participant plays in the&#xD;
    service (such as provider and consumer) and the interfaces they implement to play that role in that service. These&#xD;
    interfaces are then the types of ports on the participant, which obligates the participant to be able to play that role&#xD;
    in that service contract.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The service contract based approach extends a UML collaboration to model the structural part of the service&#xD;
    interaction. The approach can be used to specify services in which there is a contractual obligation, i.e. an&#xD;
    agreement, between two or more parties. This is the case where you have an interaction pattern that involves an&#xD;
    exchange of messages which specify (simple) interfaces on both sides.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Let us now consider the Secure Purchase service contract from the Dealer Network and demonstrate the use of the service&#xD;
    contract based approach to define a binary service contract, a multi-party service contract and a compound service&#xD;
    contract. First assume that the Secure Purchase service contract can be modelled as two separate service contracts, one&#xD;
    specifying the order interaction and the other specifying the purchase interaction.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Figure 6 shows the specification of the Place Order service contract, with the two roles consumer and provider and&#xD;
    their respective OrderPlacer and OrderTaker consumer and provider interface types. The service contract states that&#xD;
    there is a dependency between these two interfaces and this must also be modelled explicitly using UML dependencies.&#xD;
    The participants interacting in this service contract fulfil their roles by realizing the corresponding interfaces and&#xD;
    expose them through ports. From the role bindings in the services architecture we deduce that the Dealer has a request&#xD;
    port Request typed by the OrderPlacer interface, and the Manufacturer has a service port Service typed by the&#xD;
    OrderTaker interface. Notice that we have not fully specified the operation signatures and message types for the&#xD;
    interfaces.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img alt=&quot;&quot; src=&quot;./resources/dna_service_contract_figure_6_example.png&quot; width=&quot;454&quot; height=&quot;321&quot; />&lt;br />&#xD;
    &lt;strong>Figure 6:&lt;/strong> Specification of the Place Order service, consisting of two roles, their respective consumer&#xD;
    and provider interface type, and the corresponding ports on the participants&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    In the example above the service contract acts as a packaging of the two interfaces, ensuring that both interfaces are&#xD;
    a part of one service specification and not specified as two independent service specifications as two separate simple&#xD;
    interfaces. In addition to this structural specification it is recommended to specify the behaviour of the service&#xD;
    contract, i.e. the service choreography or service protocol. In fact, one can argue that the specification of the&#xD;
    service choreography is essential in order to understand how to design the interfaces to support the exchange of&#xD;
    messages. SoaML is agnostic with regards to behavioural modelling and basically states that any UML behaviour, e.g.&#xD;
    interaction models, activity models or state machines, can be used.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Figure 7 shows the specification of the service choreography using a UML interaction. Here we see that we specify a&#xD;
    conversation, i.e. message exchange, between the two participants, and this requires an interface to be implemented at&#xD;
    both sides. In this case the simple interface based approach falls short as it is not able to capture this as one&#xD;
    single service specification.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img alt=&quot;&quot; src=&quot;./resources/dna_service_contract_figure_7_example.png&quot; width=&quot;440&quot; height=&quot;518&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 7:&lt;/strong> Specification of the Place Order service choreography (behaviour)&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    The service contract based approach is useful when specifying interactions between two or more roles that implies the&#xD;
    establishment of some agreement e.g. through message exchanges. A service contract also serves as a reusable&#xD;
    specification element that can be re-used at design time to connect different participants. Furthermore, the approach&#xD;
    also supports modelling of multiparty service contracts involving three or more participants and compound service&#xD;
    contracts where existing service contracts can be used to define more granular service contracts.&amp;nbsp;&amp;nbsp;&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Let us first look at a multiparty service contract. Our example uses an Escrow purchase, where the interaction between&#xD;
    a buyer and a seller is mediated through an Escrow broker. Figure 8 shows the specification of the Escrow Purchase&#xD;
    service contract, with the three roles buyer, seller and broker and their respective Purchaser, Seller and EscrowAgent&#xD;
    consumer and provider interface types. The dependencies between the interfaces are explicitly modelled using UML&#xD;
    dependencies and the participants have ports corresponding to the role bindings in the services architecture. As can be&#xD;
    seen the ports on the Dealer, Manufacturer and EscrowAgent participants each provides one and requires two interfaces&#xD;
    in order to comply with the dependencies between the interfaces.&#xD;
&lt;/p>&#xD;
&lt;img alt=&quot;&quot; src=&quot;resources/dna_service_contract_figure_8_example.png&quot; width=&quot;468&quot; height=&quot;584&quot; />&lt;br />&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 8:&lt;/strong> Specification of the Escrow Purchase service, consisting of three roles, the respective&#xD;
    consumer interface and the two provider interface types, and the corresponding ports on the participants&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Figure 9 shows the specification of the service choreography using a UML interaction. Note that this is a multiparty&#xD;
    service contract because the buyer also interacts with the seller directly through the delivery message. With the&#xD;
    exception of the delivery, all other interactions are mediated through an Escrow broker. The service interaction starts&#xD;
    with a deposit made by the buyer to broker. At a later time a delivery is made and either accepted or grievance is sent&#xD;
    to the broker who forwards it to the seller, which may file a justification in order to clarify whether to accept or&#xD;
    refund the payment. This process repeats until the broker concludes the transaction and either makes the escrowPayment&#xD;
    to the seller or escrowRefund to the buyer.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img alt=&quot;Figure 9: Specification of the Escrow Purchase service choreography (behaviour)&quot;&#xD;
    src=&quot;resources/dna_service_contract_figure_9_example.png&quot; width=&quot;383&quot; height=&quot;600&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;strong>Figure 9:&lt;/strong> Specification of the Escrow Purchase service choreography (behaviour)&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Let us now look at a compound service contract. Note that a compound service contract should not be confused with a&#xD;
    service that is implemented by calling other services. A compound service contract defines a more granular service&#xD;
    contract based on other service contracts. Figure 10 shows the specification of the Secure Purchase compound service&#xD;
    contract, which combines the Place Order and Escrow Purchase service contracts. In the case of compound service&#xD;
    contracts, the SoaML specification prescribes that the types of the roles should be modelled as classes instead of&#xD;
    interfaces. Moreover, according to the SoaML specification they can in fact be of type service interfaces. In this&#xD;
    example we use UML classes stereotyped as either «Consumer» or «Provider». Note that the Buyer and Seller have two&#xD;
    ports, each corresponding to the role played in the Place Order and Escrow Purchase services. When a compound service&#xD;
    is used it looks no different than any other service in a services architecture, thus hiding the detail of the more&#xD;
    granular service in the high-level architecture yet providing traceability through all levels.&#xD;
&lt;/p>&#xD;
&lt;img&#xD;
alt=&quot;Figure 10: Specification of the Secure Purchase compound service contract which combines the two-party Place Order and the multi-party Escrow Purchase service contracts&quot;&#xD;
 src=&quot;resources/dna_service_contract_figure_10_example.png&quot; width=&quot;384&quot; height=&quot;420&quot; />&lt;br />&#xD;
&lt;strong>Figure 10:&lt;/strong> Specification of the Secure Purchase compound service contract which combines the two-party&#xD;
Place Order and the multi-party Escrow Purchase service contracts</mainDescription>
</org.eclipse.epf.uma:ContentDescription>
