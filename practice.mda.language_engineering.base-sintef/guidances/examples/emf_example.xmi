<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:GuidanceDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-h5QtiU5mABrPBu4niHTdiA" name="new_example,_1ZV1UNt2Ed-pTLmXJigeaQ" guid="-h5QtiU5mABrPBu4niHTdiA" changeDate="2010-10-19T13:50:07.756+0200">
  <mainDescription>&lt;h2 class=&quot;underlined_10&quot;>&#xD;
    Example #1: Metamodel for service-oriented architecture (SOA)&#xD;
&lt;/h2>&#xD;
&lt;div class=&quot;section&quot;>&#xD;
    &lt;a id=&quot;N10014&quot; name=&quot;N10014&quot;>&lt;/a>&lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Introduction&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        In order to reduce the gap between enterprise models and the service oriented implementations, a key result of A6&#xD;
        is the development of the PIM4SOA, taking on a model-driven stance. On the one hand applying this approach allows&#xD;
        the separation of concerns between the business solutions, the logical solutions and the technology used, avoiding&#xD;
        organisations having to reinvent the wheel when there are changes at the logical or technical layer. On the other,&#xD;
        using an model-drven approach makes it possible for us to implement the same system functionality on different or&#xD;
        combined platforms. For example, Web services technology could be used with peer to peer and agents technologies to&#xD;
        provide new reasoning capabilities.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        To implement the MDA approach first we need to identify the platform independent metamodel to be used to represent&#xD;
        the logical solution; and second we need to identify candidate platform specific metamodels that will be used to&#xD;
        generate the platform assets. Besides this, we require appropriate transformations between both abstraction levels,&#xD;
        and possibly transformation to the new metamodel from higher abstraction metamodels.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        The PIM for SOA metamodel covers four important aspects: service, process, information and quality of service.&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Information: in the context of virtual enterprises information represents one of the most important elements&#xD;
            that need to be described. In fact the other aspects manage or are based on information elements.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Service: our main intention is to be able to describe SOA independently from the technology used. Service&#xD;
            represents business accessible functionality.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Process: processes describe a set of interactions amongst services in terms of messages exchange.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            QoS a suitable feature is the description and the modelling of non-functional aspects related with the services&#xD;
            described.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N10027&quot; name=&quot;N10027&quot;>&lt;/a>&lt;a id=&quot;Service+metamodel&quot; name=&quot;Service+metamodel&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Service metamodel&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        This section describes the elements in the service oriented metamodel. Most of them have already been defined in&#xD;
        [2]. This section is focused on service aspects. The service oriented metamodel has the objective of describing&#xD;
        service architectures as proposed by the W3C [28]. These architectures represent the functionalities provided by a&#xD;
        system or a set of systems to achieve a shared goal. These functionalities could be represented as a service or as&#xD;
        a set of services. In this work we emphasise the concept of collaborations to address the different levels of&#xD;
        service description. In this section we sketch out the main components of the service oriented metamodel.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        &lt;img alt=&quot;&quot; src=&quot;http://www.modelbased.net/mdi/metamodelling/examples_files/metamodelling_service_metamodel.gif&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10031&quot; name=&quot;N10031&quot;>&lt;/a>&lt;a id=&quot;Collaboration&quot; name=&quot;Collaboration&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Collaboration&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Collaboration represents a pattern of interaction between participating roles. A binary collaboration specifies a&#xD;
        service. A Collaboration definition contains a set of roles (provider, requester) and a set of collaboration use.&#xD;
        Eventually it could be related with non-functional aspects. A Collaboration is related with a registry where it is&#xD;
        specified the endpoints. Basically the attributes are:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Subcollaborations: represent the usage of other collaborations&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Constraints: a collaboration could be constrained by the specification of a process.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Roles:the roles involved within the collaboration&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Nfa: this element sets up a link to quality of service model definition&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Endpoint: we can specify at design time the end points&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            RegistryItem: we can specify the registry item associated with the collaboration&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N10044&quot; name=&quot;N10044&quot;>&lt;/a>&lt;a id=&quot;CollaborationUse&quot; name=&quot;CollaborationUse&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        CollaborationUse&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A CollaborationUse represents the usage of collaboration. In other words, a CollaborationUse is the model element&#xD;
        to represent a usage of a service. The CollaborationUse contains a reference to the endpoint pointing out the&#xD;
        address. Its attributes are:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Collaboration: specify a link to the collaboration definition&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Bindings: specify a link to specific roles within the current collaboration and within the current&#xD;
            collaboration use&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            RegistryItem: specifies which the registry item is.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Nfa: specifies the link to quality of service attributes.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N10053&quot; name=&quot;N10053&quot;>&lt;/a>&lt;a id=&quot;Role&quot; name=&quot;Role&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Role&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A Role represents a part involved in a service. In fact, this part is considered as a composite structure of a&#xD;
        service. From a service point of view, a Role could be a requester or a provider. In addition a Role is described&#xD;
        as a composite structure of a collaboration or a service provider. Its attributes are:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Provides: specify the item that he/she/it would provide&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Messages: specify the messages related with this role&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            RoleType:This property specifies the type of the Role. Basically a Role can be a “requester” or a “provider”.&#xD;
            If it is not none of them we can specify it as “other” and in the property “Other” we specify the name.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Other: This property is only used for the special case where the role is neither a “requester” nor a&#xD;
            “provider”.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N10062&quot; name=&quot;N10062&quot;>&lt;/a>&lt;a id=&quot;RoleBinding&quot; name=&quot;RoleBinding&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        RoleBinding&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A RoleBinding relates a role with a usage of a service. When we specify a collaboration use we need to identify&#xD;
        which are the roles involved This relationship is made between two Roles: one inside the collaborationUse and other&#xD;
        inside a collaboration definition. Its attributes are:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Role: This element represents a link to specific role within the collaboration definition of the current&#xD;
            collaboration use&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            BoundRole: This element represents a link to specific role within the current collaboration&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N1006D&quot; name=&quot;N1006D&quot;>&lt;/a>&lt;a id=&quot;RoleType&quot; name=&quot;RoleType&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        RoleType&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        In a service oriented domain two are the RoleTypes identified: the requester and the provider. A RoleType provides&#xD;
        a meaning for a specific part inside a collaboration and collaborationuse. This element is an enumeration composed&#xD;
        by: “Provider”, “Requester” and “Other”.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10073&quot; name=&quot;N10073&quot;>&lt;/a>&lt;a id=&quot;Behaviour&quot; name=&quot;Behaviour&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Behaviour&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Behaviour is an abstract class for the specification of messages sequence within a service.&amp;nbsp; This element&#xD;
        represents a super class connecting a service aspect with process aspect.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10079&quot; name=&quot;N10079&quot;>&lt;/a>&lt;a id=&quot;ServiceProvider&quot; name=&quot;ServiceProvider&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        ServiceProvider&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A ServiceProvider specify an entity describing and specifying in its turn services, roles and constraints.&#xD;
        ServiceProvider represents a service specification containing the specification of other services. Non functional&#xD;
        aspects could also be added to specify quality aspects. These aspects are described using the OMG standard for&#xD;
        quality of service [24]. Its attributes are:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Behaviour: represents the process&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Participates: contains a set of the collaboration uses.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Roles: defines the roles involved at this level.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Nfa: establishes the link to the quality of service model&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            QosCategory: defines the category in terms of quality of service&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Type: refers to the type of provider: “Abstract” or “Executable”&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N1008C&quot; name=&quot;N1008C&quot;>&lt;/a>&lt;a id=&quot;EndPoint&quot; name=&quot;EndPoint&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        EndPoint&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        An EndPoint represents an address identifying a service. This element satisfies the W3C definition and it&#xD;
        identifies univocally a service. It contains a name and an address. Its attributes is:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Address: defines a string indicating the address&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N10095&quot; name=&quot;N10095&quot;>&lt;/a>&lt;a id=&quot;Registry&quot; name=&quot;Registry&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Registry&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A Registry model element is based on index approach containing addressable services. A Registry contains&#xD;
        RegistryItems and it references collaborations and their endpoints. It contains a set of registry items.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N1009B&quot; name=&quot;N1009B&quot;>&lt;/a>&lt;a id=&quot;RegistryItem&quot; name=&quot;RegistryItem&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        RegistryItem&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A RegistryItem represents a service and an end point. A RegistryItem is contained by a registry. Its attributes&#xD;
        are:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Endpoint: represents a link to an end point (where it is located a service)&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Collaboration: represents a link to a collaboration&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            CollaborationUse: represents a link to a collaboration use&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N100A8&quot; name=&quot;N100A8&quot;>&lt;/a>&lt;a id=&quot;Message&quot; name=&quot;Message&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Message&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A message model element defines a chunk of information sent from one role to other role in a collaboration. A&#xD;
        message is owned by a specific role. Its attributes are:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Contains: defines a set of items related with the message&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Type: defines the type of the items related with the message&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Mode: differentiates messages between “regular” (normal) or “fault” (exceptions)&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N100B5&quot; name=&quot;N100B5&quot;>&lt;/a>&lt;a id=&quot;MessageMode&quot; name=&quot;MessageMode&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        MessageMode&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        MessageMode differentiates between two kinds of messages. This element is a simple enumeration:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            “regular”: for normal messages&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            “fault”: for exceptions&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N100C0&quot; name=&quot;N100C0&quot;>&lt;/a>&lt;a id=&quot;Information+metamodel&quot; name=&quot;Information+metamodel&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Information metamodel&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        This section describes the concepts needed to model information at a platform independent level. The starting point&#xD;
        for the information-oriented metamodel are the UML constructs used in “plain vanilla” class modelling. We should be&#xD;
        careful and try to avoid introducing new unnecessary concepts for information modelling. As this metamodel is based&#xD;
        on EDOC [19] as well as on the Class related parts of the UML metamodel, we describe the basic elements and we&#xD;
        provide an overview of the related metamodels. This section describes succinctly the main elements to represent&#xD;
        information in the metamodel. Mainly it is based on UML2.0 elements&lt;br />&#xD;
        &amp;nbsp;&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        &lt;img alt=&quot;&quot;&#xD;
        src=&quot;http://www.modelbased.net/mdi/metamodelling/examples_files/metamodelling_information_metamodel.jpg&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N100CC&quot; name=&quot;N100CC&quot;>&lt;/a>&lt;a id=&quot;Item&quot; name=&quot;Item&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Item&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Item defines the set of elements that a role manages.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N100D2&quot; name=&quot;N100D2&quot;>&lt;/a>&lt;a id=&quot;ItemType&quot; name=&quot;ItemType&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        ItemType&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        ItemTypes represents simple types: string, integer and boolean.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N100D8&quot; name=&quot;N100D8&quot;>&lt;/a>&lt;a id=&quot;Association&quot; name=&quot;Association&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Association&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Association represents the association between two entities. It is used to describe complex types. Container,&#xD;
        contained and cardinality are the attributes necessary to related elements.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N100DE&quot; name=&quot;N100DE&quot;>&lt;/a>&lt;a id=&quot;Document&quot; name=&quot;Document&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Document&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Document represents an object with a specific structure and composed by entities. Document is a stereotyped package&#xD;
        containing the structure of the document.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N100E4&quot; name=&quot;N100E4&quot;>&lt;/a>&lt;a id=&quot;TypeLibrary&quot; name=&quot;TypeLibrary&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        TypeLibrary&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        TypeLibrary defines a packaging structure containing some types of the application TypeLibrary is a stereotyped&#xD;
        package containing data types.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N100EA&quot; name=&quot;N100EA&quot;>&lt;/a>&lt;a id=&quot;Entity&quot; name=&quot;Entity&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Entity&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Entity represents a structure element of information. Entity is a stereotyped class.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N100F0&quot; name=&quot;N100F0&quot;>&lt;/a>&lt;a id=&quot;Process+metamodel&quot; name=&quot;Process+metamodel&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Process metamodel&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        The process metamodel is founded on work still in progress [10] for the BPDM [20] RFP from the OMG, with some&#xD;
        modifications to allow integration with cross business process models and the other PIM4SOA packages.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        The process elements of the PIM4SOA metamodel are shown below. The process aspect is closely linked to the Service&#xD;
        aspect, the primary link being the abstract class ‘Scope’ above, which can be instantiated as a Process belonging&#xD;
        to a ServiceProvider from that aspect.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        The process contains a set of Steps (generally Tasks), representing actions carried out by the Process. A Process&#xD;
        consists of StructuredTasks (sub-processes), Steps (atomic tasks and actions, at the PIM level), and&#xD;
        Interactions/Flows linking the tasks together. These essentially fall into two categories, interactions with other&#xD;
        Service Providers, or specialised actions requiring implementation beyond the scope of this model. For example,&#xD;
        manual tasks to be processed by humans, or extensive computation requiring platform specific code.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        The Process also contains a set of Flows between these actions, which may be specialises (ItemFlow) to indicate the&#xD;
        transfer of specific data. This allows flexibility in that a business modeller bay choose to start by showing only&#xD;
        control flow, and later refine the model to include information. This links in to the Item/ItemType parts of the&#xD;
        Information aspect. Flows may diverge or reconverge using Guard and Join specifications.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        &lt;img alt=&quot;&quot;&#xD;
        src=&quot;http://www.modelbased.net/mdi/metamodelling/examples_files/metamodelling_process_metamodel_1.gif&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;img alt=&quot;&quot; src=&quot;http://www.modelbased.net/mdi/metamodelling/examples_files/metamodelling_process_metamodel_2.gif&quot; />&lt;a&#xD;
    id=&quot;N10103&quot; name=&quot;N10103&quot;>&lt;/a>&lt;a id=&quot;Scope&quot; name=&quot;Scope&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Scope&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Scope is an abstract container for individual behavioural steps. This is subclassed only by Process and&#xD;
        StructuredTask (Process is the top level behavioural object, StructuredTask may be used to group related Steps in a&#xD;
        ‘subroutine’ like manner.)&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10109&quot; name=&quot;N10109&quot;>&lt;/a>&lt;a id=&quot;Step&quot; name=&quot;Step&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Step&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Step is a single node in a process, such as making a decision or calling an external service. The ‘everyday’&#xD;
        specialization of Step is Task.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N1010F&quot; name=&quot;N1010F&quot;>&lt;/a>&lt;a id=&quot;Process&quot; name=&quot;Process&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Process&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Implements a behaviour for a service provider, as a set of tasks and decisions (Steps) linked by control flows&#xD;
        (Flows), optionally including detail on the exchanged messages / items.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10115&quot; name=&quot;N10115&quot;>&lt;/a>&lt;a id=&quot;Structured+Task&quot; name=&quot;Structured+Task&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Structured Task&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A composite task consisting of a collection of Steps related to a specific subsection of a Process&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N1011B&quot; name=&quot;N1011B&quot;>&lt;/a>&lt;a id=&quot;Task&quot; name=&quot;Task&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Task&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        The low level ‘building blocks’ of a process – these might be for example calls to another service (which can be&#xD;
        transformed largely automatically to an implementation platform, with reference to the relevant collaborations) or&#xD;
        might require manual intervention – either in the form of hand coded functions, or human interaction with the&#xD;
        process.&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Collaboration Use Path: This is a path through the tree of CollaborationUses associated with this&#xD;
            ServiceProvider. It must start with a CollaborationUse participated in by this SP, and walk through any sub&#xD;
            collaborations to the ‘real’ collaboration being implemented by this Task&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N10124&quot; name=&quot;N10124&quot;>&lt;/a>&lt;a id=&quot;Interaction&quot; name=&quot;Interaction&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Interaction&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Defines an interface for input or output flows on a Step. Can be viewed as a set of Pins, though it is not&#xD;
        compulsory to refine the model to this level (depending on aims of the model). If the step is viewed as a service,&#xD;
        this is similar to the declaration of a method/function in the interface (specifying a set of parameters or a&#xD;
        ‘return value’).&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N1012A&quot; name=&quot;N1012A&quot;>&lt;/a>&lt;a id=&quot;Pin&quot; name=&quot;Pin&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Pin&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Input or output for a specific item type when a flow connects to a Step in the Process. An example might be a&#xD;
        CheckStockLevel task, with an input interaction, where one pin is tied to the item code being checked (perhaps of&#xD;
        item type StockCode). If the step is viewed as a service, this is similar to an individual parameter to a function,&#xD;
        or a component of the return value. The Parameter or Attribute referenced should be an appropriate sub-component of&#xD;
        the message for the owning interaction.&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            (ONE of the following should be used, dependant on message type being refined)&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Parameter: where a message has been defined as a set of items, this refers to the particular item required.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Attribute: where the message has been defined with reference to an Entity, this selects the attribute of that&#xD;
            entity required&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N10137&quot; name=&quot;N10137&quot;>&lt;/a>&lt;a id=&quot;Flow&quot; name=&quot;Flow&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Flow&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Flows provide the links between Steps (tasks etc.) in the behaviour. A flow may be associated with a message type&#xD;
        being transported.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N1013D&quot; name=&quot;N1013D&quot;>&lt;/a>&lt;a id=&quot;ItemFlow&quot; name=&quot;ItemFlow&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        ItemFlow&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A flow between specific pins on interactions to show precise relationships between output from one Step/Interaction&#xD;
        and input on another. This is the primary mechanism for data flow in the process model (see Pin)&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10143&quot; name=&quot;N10143&quot;>&lt;/a>&lt;a id=&quot;JoinSpecification&quot; name=&quot;JoinSpecification&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        JoinSpecification&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Defines convergence behaviour when two flows provide input to a single Step/Interaction&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            rule: String defining condition. Interpretation is currently left as platform specific (for instance, BPEL&#xD;
            transform will attempt to treat this as an Xpath expression)&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N1014C&quot; name=&quot;N1014C&quot;>&lt;/a>&lt;a id=&quot;GuardSpecification&quot; name=&quot;GuardSpecification&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        GuardSpecification&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Defines conditions (e.g. in terms of Pin contents) under which an output flow is or is not activated – most useful&#xD;
        from decision nodes.&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            rule: String defining condition. Interpretation is currently left as platform specific (for instance, BPEL&#xD;
            transform will attempt to treat this as an Xpath expression)&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N10155&quot; name=&quot;N10155&quot;>&lt;/a>&lt;a id=&quot;Quality+of+service+(QoS)+metamodel&quot;&#xD;
    name=&quot;Quality+of+service+(QoS)+metamodel&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Quality of service (QoS) metamodel&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        In this section we address quality aspects at service level and from a service oriented point of view. As starting&#xD;
        point this part of the metamodel is based on the quality of service OMG standard called UMLTM Profile for Modeling&#xD;
        Quality of Service and Fault Tolerance Characteristics and Mechanisms [24]. Therefore we have extracted a set of&#xD;
        elements needed from this standard to describe QoS elements. Our main intention is not to implement the profile in&#xD;
        its entirety but only the necessary elements for this domain. Additional elements need to be added to set the&#xD;
        relationships between quality aspects and the other aspects.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        &lt;img alt=&quot;&quot; src=&quot;http://www.modelbased.net/mdi/metamodelling/examples_files/metamodelling_qos_metamodel.gif&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Most of elements in this metamodel have been defined in the OMG standard for specifying quality of service [24].&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10161&quot; name=&quot;N10161&quot;>&lt;/a>&lt;a id=&quot;NFA&quot; name=&quot;NFA&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        NFA&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        NFA represents Non-Functional Aspects for a specific usage of a service. This element is defined in Collaboration&#xD;
        and ServiceProvider specification. This element is related with CollaborationUse element.&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            A NFA element is related with a service usage and it specifies two important concepts. On the one hand it&#xD;
            specifies a set of quality characteristics for a service use, and on the other hand it specifies a set of&#xD;
            values for those characteristics and the QoSConstraints applied within the service.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
&lt;/div>&#xD;
&lt;a id=&quot;N1016A&quot; name=&quot;N1016A&quot;>&lt;/a>&lt;a id=&quot;Example+#2:+Metamodel+for+Web+services&quot;&#xD;
name=&quot;Example+#2:+Metamodel+for+Web+services&quot;>&lt;/a> &#xD;
&lt;h2 class=&quot;underlined_10&quot;>&#xD;
    Example #2: Metamodel for Web services&#xD;
&lt;/h2>&#xD;
&lt;div class=&quot;section&quot;>&#xD;
    &lt;a id=&quot;N1016E&quot; name=&quot;N1016E&quot;>&lt;/a>&lt;a id=&quot;Introduction-N1016E&quot; name=&quot;Introduction-N1016E&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Introduction&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        The world of Web services is far from being one coherent set of interrelated specifications. The different&#xD;
        specifications that make up the so-called WS-* stack arose out of a combination of loosely-coordinated ad-hoc&#xD;
        industry efforts, regular standardization processes such as that of the W3C [1] or OASIS [2], and vendors competing&#xD;
        by pushing for “their” specification to become a de-facto standard.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        The total number of WS-* specifications proposed at some point or another in time is not far from a hundred. Some&#xD;
        of these specifications have since then been superseded, abandoned or merged together, while others are still in&#xD;
        the process of getting finalised. It will probably take a few more years for all parties to agree on a common set&#xD;
        of specification. In the meantime, practitioners have to do with a WS-* landscape that is a combination of mature&#xD;
        and accepted specifications, such as XML, SOAP and WSDL, nearly-there specifications, such as WS-Addressing and&#xD;
        WS-Security, and still-immature specifications, such as WS-ReliableMessaging.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        &lt;img alt=&quot;&quot;&#xD;
        src=&quot;http://www.modelbased.net/mdi/metamodelling/examples_files/metamodelling_web_services_metamodel.gif&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        The figure above shows a logical grouping of the WS-* metamodels.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N1017C&quot; name=&quot;N1017C&quot;>&lt;/a>&lt;a id=&quot;Web+Services+Definition+Language+(WSDL)&quot;&#xD;
    name=&quot;Web+Services+Definition+Language+(WSDL)&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Web Services Definition Language (WSDL)&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        This section describes the WSDL 1.1 metamodel which has been developed based on information described in [3] and&#xD;
        [5]. WSDL 1.1 is an XML format for describing network services as a set of endpoints operating on messages. The&#xD;
        operations and messages are described abstractly, and then bound to a concrete network protocol and message format&#xD;
        to define an endpoint. Related concrete endpoints are combined into abstract endpoints (services).&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        &lt;img alt=&quot;&quot; src=&quot;http://www.modelbased.net/mdi/metamodelling/examples_files/metamodelling_wsdl_metamodel.gif&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        A WSDL document is simply a set of definitions. There is a definitions element at the root, and definitions inside.&#xD;
        Services are defined using six major elements:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            &lt;strong>Types&lt;/strong>, which provides data type definitions used to describe the messages exchanged.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            &lt;strong>Message&lt;/strong>, which represents an abstract definition of the data being transmitted. A message&#xD;
            consists of logical parts, each of which is associated with a definition within some type system.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            &lt;strong>Port type&lt;/strong>, which is a set of abstract operations. Each operation refers to an input message&#xD;
            and output messages.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            &lt;strong>Binding&lt;/strong>, which specifies concrete protocol and data format specifications for the operations&#xD;
            and messages defined by a particular port type.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            &lt;strong>Port&lt;/strong>, which specifies an address for a binding, thus defining a single communication endpoint.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            &lt;strong>Service&lt;/strong>, which is used to aggregate a set of related ports.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;a id=&quot;N101A1&quot; name=&quot;N101A1&quot;>&lt;/a>&lt;a id=&quot;Types&quot; name=&quot;Types&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Types&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        The types element encloses data type definitions that are relevant for the exchanged messages. For maximum&#xD;
        interoperability and platform neutrality, WSDL prefers the use of XSD as the canonical type system, and treats it&#xD;
        as the intrinsic type system. The XSD type system can be used to define the types in a message regardless of&#xD;
        whether or not the resulting wire format is actually XML, or whether the resulting XSD schema validates the&#xD;
        particular wire format.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N101A7&quot; name=&quot;N101A7&quot;>&lt;/a>&lt;a id=&quot;Message-N101A7&quot; name=&quot;Message-N101A7&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Message&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        Messages consist of one or more logical parts. Each part is associated with a type from some type system using a&#xD;
        message-typing attribute. The set of message-typing attributes is extensible. WSDL defines several such&#xD;
        message-typing attributes for use with XSD:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Element, refers to an XSD element using a QName.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Type, refers to an XSD simple type or complex type using a QName.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;p>&#xD;
        The message name attribute provides a unique name among all messages defined within the enclosing WSDL document.&#xD;
        The part name attribute provides a unique name among all the parts of the enclosing message.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N101B4&quot; name=&quot;N101B4&quot;>&lt;/a>&lt;a id=&quot;Port+type&quot; name=&quot;Port+type&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Port type&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A port type is a named set of abstract operations and the abstract messages involved. The port type name attribute&#xD;
        provides a unique name among all port types defined within in the enclosing WSDL document. An operation is named&#xD;
        via the name attribute.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        WSDL has four transmission primitives that an endpoint can support:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            One-way. The endpoint receives a message.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Request-response. The endpoint receives a message, and sends a correlated message.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Solicit-response. The endpoint sends a message, and receives a correlated message.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Notification. The endpoint sends a message.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;p>&#xD;
        WSDL refers to these primitives as operations.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N101C7&quot; name=&quot;N101C7&quot;>&lt;/a>&lt;a id=&quot;Binding&quot; name=&quot;Binding&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Binding&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A binding defines message format and protocol details for operations and messages defined by a particular port&#xD;
        type. There may be any number of bindings for a given port type. The name attribute provides a unique name among&#xD;
        all bindings defined within in the enclosing WSDL document. A binding references the port type that it binds using&#xD;
        the type attribute.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Binding extensibility elements are used to specify the concrete grammar for the input, output, and fault messages.&#xD;
        An operation element within a binding specifies binding information for the operation with the same name within the&#xD;
        binding's port type.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        A binding must specify exactly one protocol. A binding must not specify address information&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N101D1&quot; name=&quot;N101D1&quot;>&lt;/a>&lt;a id=&quot;Port&quot; name=&quot;Port&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Port&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A port defines an individual endpoint by specifying a single address for a binding. The name attribute provides a&#xD;
        unique name among all ports defined within in the enclosing WSDL document. The binding attribute (of type QName)&#xD;
        refers to the binding using the linking rules defined by WSDL.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Binding extensibility elements are used to specify the address information for the port.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        A port must not specify more than one address. A port must not specify any binding information other than address&#xD;
        information.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N101DB&quot; name=&quot;N101DB&quot;>&lt;/a>&lt;a id=&quot;Service&quot; name=&quot;Service&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Service&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A service groups a set of related ports together. The name attribute provides a unique name among all services&#xD;
        defined within in the enclosing WSDL document.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Ports within a service have the following relationship:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            None of the ports communicate with each other (e.g. the output of one port is not the input of another).&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            If a service has several ports that share a port type, but employ different bindings or addresses, the ports&#xD;
            are alternatives. Each port provides semantically equivalent behavior (within the transport and message format&#xD;
            limitations imposed by each binding). This allows a consumer of a WSDL document to choose particular port(s) to&#xD;
            communicate with based on some criteria (protocol, distance, etc.).&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            By examining it's ports, we can determine a service's port types. This allows a consumer of a WSDL document to&#xD;
            determine if it wishes to communicate to a particular service based whether or not it supports several port&#xD;
            types. This is useful if there is some implied relationship between the operations of the port types, and that&#xD;
            the entire set of port types must be present in order to accomplish a particular task.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
&lt;/div>&#xD;
&lt;a id=&quot;N101EA&quot; name=&quot;N101EA&quot;>&lt;/a>&lt;a id=&quot;Example+#3:+Metamodel+for+BDI+agents&quot;&#xD;
name=&quot;Example+#3:+Metamodel+for+BDI+agents&quot;>&lt;/a> &#xD;
&lt;h2 class=&quot;underlined_10&quot;>&#xD;
    Example #3: Metamodel for BDI agents&#xD;
&lt;/h2>&#xD;
&lt;div class=&quot;section&quot;>&#xD;
    &lt;p>&#xD;
        &lt;img alt=&quot;&quot; src=&quot;http://www.modelbased.net/mdi/metamodelling/examples_files/metamodelling_bdi_metamodel.jpg&quot; />&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        In the design of a multiagent systems (MAS) we can distinguish models that describe the entities at the MAS level&#xD;
        and models that describe the internal structure and/or the behaviour of individual agents. At the MAS we find&#xD;
        concepts like teams, agents, roles, events, and plans. At the level of individual agents we find the same concepts&#xD;
        again (note that teams can be viewed as individual agents and vice versa), where events and plans are described in&#xD;
        much more detail, and additional concepts like capabilities and belief data. The figure displays the metamodel for&#xD;
        BDI agents in JDE when the system is used in the more general team mode. Teams are formed by groups of agents but&#xD;
        may also consist of only a single agent. The metamodel explains how the basic concepts relate to each other. For&#xD;
        goal-oriented computing the concepts Event and Plan or TeamPlan, respectively, are most important and will be&#xD;
        discussed in more detail in the rest of this section.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N101F4&quot; name=&quot;N101F4&quot;>&lt;/a>&lt;a id=&quot;Events&quot; name=&quot;Events&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Events&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        Events motivate an agent to take action. There are a number of event types in BDI agents, each with different uses.&#xD;
        These different event types help to model:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Internal stimuli – events that an agent sends to itself, usually as a result of executing reasoning methods in&#xD;
            plans that an agent has. These internal events are integral to the ongoing execution of an agent and the&#xD;
            reasoning that it undertakes.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            External stimuli – such as messages from other agents, or percept that an agent receives from its environment.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Motivations – that the agent may have, such as goals that the agent is committed to achieving.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;p>&#xD;
        Events are the origin of all activity within an agent-oriented system. In the absence of events an agent sits idle.&#xD;
        Whenever an event occurs, an agent initiates a task to handle it. This task can be thought of as a thread of&#xD;
        activity within the agent. The task causes the agent to choose between the plans it has available, executing a&#xD;
        selected plan or plan set (depending on the event processing model chosen) until it succeeds or fails.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10203&quot; name=&quot;N10203&quot;>&lt;/a>&lt;a id=&quot;Plans&quot; name=&quot;Plans&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Plans&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        The Plan class describes a sequence of actions that an agent can take when an event occurs. Whenever an event is&#xD;
        posted and an agent adopts a task to handle it, the first thing the agent does is try to find a plan to handle the&#xD;
        event.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Plans can be thought of as pages from a procedures manual, or even as being like methods and functions from more&#xD;
        conventional programming languages. They describe, in explicit detail, exactly what an agent should do when a given&#xD;
        event occurs. Equipped with a set of plans, an agent has a set of skills and procedural knowledge that it can draw&#xD;
        upon as required. When the event that a plan addresses occurs, the agent can execute this plan to handle it.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Each plan is capable of handling a single event. The event it can handle is identified by the plan's #handles event&#xD;
        declaration. When an instance of a given event arises, the agent may execute one of the plans that declare they&#xD;
        handle this event.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        An agent may further discriminate between plans that declare they handle an event by determining whether a plan is&#xD;
        relevant. It does this by executing the relevant() method of each plan. If plans do not specify a relevant()&#xD;
        method, they are relevant for all instances of that event. When present, the relevant() method lets a plan specify&#xD;
        exactly which instance of a given event it is relevant for.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Once the relevant plan(s) have been identified, the agent determines which of these are applicable. It does this by&#xD;
        executing the plans' context() method. The context method is a logical expression that can bind the values of the&#xD;
        plan's logical members. For every possible set of bindings, a separate applicable instance of the plan is&#xD;
        generated.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        When the agent has found all applicable instances of each relevant plan, it selects one of these to execute. If the&#xD;
        event is a BDI event, this may cause a PlanChoice event to be posted, which may initiate some meta-level reasoning&#xD;
        within the agent to select the most appropriate plan instance. The Events section has more details on meta-level&#xD;
        reasoning.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        When the agent executes a plan, it starts by executing the plan's body() method. The body method is a special kind&#xD;
        of method called a reasoning method. Reasoning methods are quite different from ordinary methods in Java, as they&#xD;
        are bound by extra logical rules and conditions. Each statement in a reasoning method is treated as a logical&#xD;
        statement that can either succeed or fail.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Failure of a plan statement will cause the body() method to fail unless the plan specifically allows for this&#xD;
        possibility. If execution proceeds to the end of the body() method, the body() method succeeds.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        The body() method can call other reasoning methods as it executes. These reasoning methods must be declared in the&#xD;
        plan using the #reasoning method declaration. They help break complex processing down into smaller components and&#xD;
        make plans both simpler to understand and more scalable.&#xD;
    &lt;/p>&#xD;
&lt;/div></mainDescription>
</org.eclipse.epf.uma:GuidanceDescription>
