<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-wVzrEa-9ISfSiVf7XDn5mw" name="new_supporting_material,_uZuCQFYAEeCmC7fuNTHhhQ" guid="-wVzrEa-9ISfSiVf7XDn5mw" changeDate="2011-03-24T11:24:16.732+0100">
  <mainDescription>&lt;h2 class=&quot;underlined_10&quot;>&#xD;
    What is a metamodel?&#xD;
&lt;/h2>&#xD;
&lt;div class=&quot;section&quot;>&#xD;
    &lt;p>&#xD;
        Metamodelling is a controversial topic which is currently critical within the UML/OMG/MDA community.&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            A metamodel is just another model (e.g. written in UML) and is thus a model of a set of models.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Metamodels are specifications. Models are valid if no false statements according to metamodel (e.g.&#xD;
            well-formed)&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Metamodels typically represents domain-specific models (real-time systems, safety critical systems, e-business)&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            The domain of metamodelling is language definition. A metamodel is a model of some part of a language. Which&#xD;
            part depends on how the metamodel is to be used. Examples of parts are syntax, semantics, views and diagrams.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
    &lt;p>&#xD;
        Then we also have what is known as a meta-metamodel. This can said to be a model of metamodels. Reflexive metamodel&#xD;
        are expressed using itself. A minimal reflexive metamodel contains all of the parts used to describe the set of&#xD;
        models that are of interest.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        In its broadest sense, a metamodel is a model of a modelling language. The term ”meta” means transcending or above,&#xD;
        emphasising the fact that a metamodel describes a modelling language at a higher level of abstraction than the&#xD;
        modelling language itself. In order to understand what a metamodel is, it is useful to understand the difference&#xD;
        between a metamodel and a model. Whilst a metamodel is also a model, a metamodel has two main distinguishing&#xD;
        characteristics.&#xD;
    &lt;/p>&#xD;
    &lt;ol>&#xD;
        &lt;li>&#xD;
            Firstly, it must capture the essential features and properties of the language that is being modelled. Thus, a&#xD;
            metamodel should be capable of describing a language’s concrete syntax, abstract syntax and semantics.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Secondly, a metamodel must be part of a metamodel architecture. Just as we can use metamodels to describe the&#xD;
            valid models or programs permitted by a language, a metamodel architecture enables a metamodel to be viewed as&#xD;
            a model, which itself is described by another metamodel. This allows all metamodels to be described by a single&#xD;
            metamodel. This single metamodel, sometimes known as a meta-metamodel, is the key to metamodelling as it&#xD;
            enables all modelling languages to be described in a unified way.&#xD;
        &lt;/li>&#xD;
    &lt;/ol>&#xD;
&lt;/div>&#xD;
&lt;a id=&quot;N10028&quot; name=&quot;N10028&quot;>&lt;/a>&lt;a id=&quot;Why+metamodel?&quot; name=&quot;Why+metamodel?&quot;>&lt;/a> &#xD;
&lt;h2 class=&quot;underlined_10&quot;>&#xD;
    Why metamodel?&#xD;
&lt;/h2>&#xD;
&lt;div class=&quot;section&quot;>&#xD;
    &lt;p>&#xD;
        System development is fundamentally based on the use of languages to capture and relate different aspects of the&#xD;
        problem domain. The benefit of metamodelling is its ability to describe these languages in a unified way. This&#xD;
        means that the languages can be uniformly managed and manipulated thus tackling the problem of language diversity.&#xD;
        For instance, mappings can be constructed between any number of languages provided that they are described in the&#xD;
        same metamodelling language. Another benefit is the ability to define semantically rich languages that abstract&#xD;
        from implementation specific technologies and focus on the problem domain at hand. Using metamodels, many different&#xD;
        abstractions can be defined and combined to create new languages that are specifically tailored for a particular&#xD;
        application domain. Productivity is greatly improved as a result.&#xD;
    &lt;/p>&#xD;
    &lt;p>&#xD;
        Uses for a metamodel can be summarised as follows:&#xD;
    &lt;/p>&#xD;
    &lt;ul>&#xD;
        &lt;li>&#xD;
            Define the syntax and semantics of a language.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Explain the language.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Compare languages rigorously.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Specify requirements for a tool for the language.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Specify a language to be used in a meta-tool.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Enable interchange between tools.&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            Enable mapping between models.&#xD;
        &lt;/li>&#xD;
    &lt;/ul>&#xD;
&lt;/div>&#xD;
&lt;a id=&quot;N1003F&quot; name=&quot;N1003F&quot;>&lt;/a>&lt;a id=&quot;How+to+metamodel?&quot; name=&quot;How+to+metamodel?&quot;>&lt;/a> &#xD;
&lt;h2 class=&quot;underlined_10&quot;>&#xD;
    How to metamodel?&#xD;
&lt;/h2>&#xD;
&lt;div class=&quot;section&quot;>&#xD;
    &lt;p>&#xD;
        There is a clearly defined process to constructing metamodels, which does at least make the task a well-defined, if&#xD;
        iterative, process. The process has the following basic steps:&#xD;
    &lt;/p>&#xD;
    &lt;ol>&#xD;
        &lt;li>&#xD;
            defining abstract syntax&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            defining well-formedness rules and meta-operations&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            defining concrete syntax&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            defining semantics&#xD;
        &lt;/li>&#xD;
        &lt;li>&#xD;
            constructing mappings to other languages&#xD;
        &lt;/li>&#xD;
    &lt;/ol>&#xD;
    &lt;a id=&quot;N10050&quot; name=&quot;N10050&quot;>&lt;/a>&lt;a id=&quot;Abstract+syntax&quot; name=&quot;Abstract+syntax&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Abstract syntax&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        The metamodel describes the abstract syntax of a language. The abstract syntax of a language describes the&#xD;
        vocabulary of concepts provided by the language and how they may be combined to create models. It consists of a&#xD;
        definition of the concepts, the relationships that exist between concepts and well-formedness rules that state how&#xD;
        the concepts may be legally combined.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10056&quot; name=&quot;N10056&quot;>&lt;/a>&lt;a id=&quot;Concrete+syntax&quot; name=&quot;Concrete+syntax&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Concrete syntax&#xD;
    &lt;/h3>&#xD;
    &lt;a id=&quot;N1005A&quot; name=&quot;N1005A&quot;>&lt;/a>&lt;a id=&quot;Visual+syntax&quot; name=&quot;Visual+syntax&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Visual syntax&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A visual syntax presents a model or program in a diagrammatical form. A visual syntax consists of a number of&#xD;
        graphical icons that represent views on an underlying model.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10060&quot; name=&quot;N10060&quot;>&lt;/a>&lt;a id=&quot;Textual+syntax&quot; name=&quot;Textual+syntax&quot;>&lt;/a> &#xD;
    &lt;h4>&#xD;
        Textual syntax&#xD;
    &lt;/h4>&#xD;
    &lt;p>&#xD;
        A textual syntax enables models or programs to be described in a structured textual form. A textual syntax can take&#xD;
        many forms, but typically consists of a mixture of declarations, which declare specific objects and variables to be&#xD;
        available, and expressions, which state properties relating to the declared objects and variables.&#xD;
    &lt;/p>&#xD;
    &lt;a id=&quot;N10066&quot; name=&quot;N10066&quot;>&lt;/a>&lt;a id=&quot;Semantics&quot; name=&quot;Semantics&quot;>&lt;/a> &#xD;
    &lt;h3 class=&quot;underlined_5&quot;>&#xD;
        Semantics&#xD;
    &lt;/h3>&#xD;
    &lt;p>&#xD;
        An abstract syntax conveys little information about what the concepts in a language actually mean. Therefore,&#xD;
        additional information is needed in order to capture the semantics of a language. Defining a semantics for a&#xD;
        language is important in order to be clear about what the language represents and means.&#xD;
    &lt;/p>&#xD;
&lt;/div></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
